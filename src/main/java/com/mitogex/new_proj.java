/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package com.mitogex;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.ButtonGroup;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JEditorPane;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;

/**
 *
 * @author mitogex
 */
public class new_proj extends javax.swing.JFrame {

    /**
     * Creates new form new_proj
     */
    private ComboBoxUpdater comboBoxUpdater;
    private boolean containsGz = false;
    private boolean containsBam = false;
    private boolean containsFasta = false;
    private JTextField fastpCore;
    private JTextField fastpQualityField;
    private JTextField fastpUnqualified_base;
    private JTextField fastpReadLengthField;
    private JTextField bwaThreadsField;
    private JTextField bwaMinimumScore;
    private JTextField fastQCCore;
    private JTextField gatkMemoryField;
    private JTextField qualimapThreads;
//    private JTextField mutect2FilterField;
    private JCheckBox gatkCheck;
    private JCheckBox mitImpactCheck;
    private JCheckBox haplogrepCheck;
    private JCheckBox fastTreeCheck;
    private JCheckBox haploCheckCheck;
    private JCheckBox mutect2Check;
    private JCheckBox fastpCheck;
    private JCheckBox fastQCCheck;
    private JCheckBox bwaCheck;
    private JCheckBox qualimapCheck;
    
    public new_proj(ComboBoxUpdater comboBoxUpdater) {
        this.comboBoxUpdater = comboBoxUpdater;
        initComponents();
        setLocationRelativeTo(null);
        // Set tooltip visibility settings
        ToolTipManager.sharedInstance().setInitialDelay(0);  // Show tooltip immediately
        ToolTipManager.sharedInstance().setDismissDelay(Integer.MAX_VALUE);  // Keep tooltip visible while typing
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jTextField1 = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jCheckBox1 = new javax.swing.JCheckBox();
        jButton2 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();
        jLabel15 = new javax.swing.JLabel();
        jTextField2 = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("New Project");

        jTextField1.setText("Select directory...");
        jTextField1.setEnabled(false);

        jButton1.setText("Browse...");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Liberation Sans", 0, 18)); // NOI18N
        jLabel1.setText("Directory");

        jLabel2.setFont(new java.awt.Font("Liberation Sans", 0, 18)); // NOI18N
        jLabel2.setText("Reference");

        jCheckBox1.setSelected(true);
        jCheckBox1.setText("GRCh38");
        jCheckBox1.setEnabled(false);

        jButton2.setText("Submit");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jButton3.setText("Cancel");

        jLabel15.setFont(new java.awt.Font("Liberation Sans", 0, 18)); // NOI18N
        jLabel15.setText("Project name");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(9, 9, 9)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel15)
                    .addComponent(jLabel2)
                    .addComponent(jLabel1))
                .addGap(29, 29, 29)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jCheckBox1)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(jTextField2, javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jTextField1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 290, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton1)))
                .addGap(0, 10, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jButton2)
                .addGap(18, 18, 18)
                .addComponent(jButton3)
                .addGap(178, 178, 178))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel15)
                    .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton1)
                    .addComponent(jLabel1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jCheckBox1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton2)
                    .addComponent(jButton3))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        String workingDir = System.getProperty("user.dir");
        String new_workingDir = workingDir.replaceAll("target", "");
        String concat = new_workingDir.concat("/Results/Fasta");
        //    String concat = workingDir.concat("/Software/uploaded/R1.fastq.gz");
        String uploaded_file = "Files are uploaded in the folder: ";
        String concat_upload = uploaded_file.concat(concat);
        String file_type = "";
        System.out.println(concat);
        JFileChooser chooser = new JFileChooser();

        chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        // optionally set chooser options ...
        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            File file = chooser.getSelectedFile();
            // read  and/or display the file somehow. ....
            String currentFileBeingEdited = file.getAbsolutePath();
            this.jTextField1.setText(currentFileBeingEdited);
            this.jTextField1.setEnabled(false);
            System.out.println("Selected Directory: "
                    + chooser.getCurrentDirectory());

            File[] list_files = file.listFiles();
            if (list_files != null) {
                for (File file2 : list_files) {
                    if (file2.isFile()) {
                        String fileName = file2.getName();
                        if (fileName.endsWith(".gz")) {
                            containsGz = true;
                        } else if (fileName.endsWith(".bam")) {
                            containsBam = true;
                        } else if (fileName.endsWith(".fasta")) {
                            containsFasta = true;
                        }
                    }
                }
            }

            // Print the detected files for debugging
            if (containsGz) {
                System.out.println(".gz files detected.");
            }
            if (containsBam) {
                System.out.println(".bam files detected: Disabling Quality Control.");

            }
            if (containsFasta) {
                System.out.println(".fasta files detected: Enabling Phylogenetic Tree.");
            }

            String path_Program = new_workingDir.concat("/Software/scripts/./select_dir.sh");

            String path_folder = "Select folder is Successful\n";
            String path_folder1 = new_workingDir.concat("/Software/uploaded");
            String path_concat = path_folder.concat(path_folder1);
//        System.out.println(path_Program);
            Runtime r1 = Runtime.getRuntime();
            int label = Runtime.getRuntime().availableProcessors();
            String cores = String.valueOf(label);
            String[] selectdir_command = {path_Program, new_workingDir, cores, file.getAbsolutePath()};

//        System.out.println(label);
            try {
//            Process p1 = r1.exec(selectdir_command);
                JOptionPane.showMessageDialog(null,
                        "Selecting directory...\n press ok button and wait until process success",
                        "Select directory",
                        JOptionPane.WARNING_MESSAGE);

                ProcessBuilder builder = new ProcessBuilder(selectdir_command);
                builder.redirectErrorStream(true);
                Process p1 = builder.start();

                InputStream itsOutput = p1.getInputStream();
                BufferedReader reader = new BufferedReader(new InputStreamReader(itsOutput));
                BufferedReader stdError = new BufferedReader(new InputStreamReader(p1.getErrorStream()));
// Wrap the stream in a Reader ...
                String line = null;
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                }
                while ((line = stdError.readLine()) != null) {
                    System.out.println(line);
                }
                p1.waitFor();
                if (p1.exitValue() == 0) {
                    JOptionPane.showMessageDialog(null,
                            "Directory selected.");

                    if (file_type.equals("fasta")) {
                        File sourceDir = new File(currentFileBeingEdited);
                        File destinationDir = new File(concat);
                        File[] files = sourceDir.listFiles();
                        for (File f : files) {
                            Path sourcePath = Paths.get(sourceDir.getAbsolutePath() + "//" + f.getName());
                            Path destinationPath = Paths.get(destinationDir.getAbsolutePath() + "//" + f.getName());

                            try {
                                Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);
                            } catch (IOException e) {
                                //moving file failed.

                            }
                        }
                    }

//                System.out.println(path_concat);
                } else {
                    JOptionPane.showMessageDialog(null,
                            "command failed.");
                }
            } catch (IOException | InterruptedException ex) {
                Logger.getLogger(new_proj.class.getName()).log(Level.SEVERE, (String) null, ex);
            }
        } else {
            // user changed their mind
            System.out.println("Cancelled by user.");
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed

        // Ensure that both text fields are not empty
        if (jTextField2.getText().trim().isEmpty() || jTextField1.getText().trim().isEmpty() || jTextField1.getText().equals("Select directory...")) {
            JOptionPane.showMessageDialog(this,
                    "Please ensure both Project Name and Directory are filled in before submitting.",
                    "Input Required",
                    JOptionPane.WARNING_MESSAGE);
            return; // Exit early if any field is empty or if jTextField1 still has the default text
        }

        String workingDir = System.getProperty("user.dir");
        String new_workingDir = workingDir.replaceAll("target", "");
        String path_Program = new_workingDir.concat("/Software/scripts/./pipeline_rCRS.sh");
        String path_Program2 = new_workingDir.concat("/Software/scripts/./BAM_pipeline_rCRS.sh");
        String path_folder = "All process are successful\nThe result files are available at: " + new_workingDir + "/Results";
        String path_folder1 = new_workingDir.concat("/Software/file_log");
        String path_concat = path_folder.concat(path_folder1);
        JPanel check_files = new JPanel();
        check_files.setLayout(new GridLayout(0, 1));
        String all_files_path = path_folder1.concat("/all_file_log.txt");

        try (BufferedReader br = new BufferedReader(new FileReader(all_files_path))) {
            StringBuilder sb = new StringBuilder();
            String line = br.readLine();
            sb.append("<html>");
            int lineNumber = 1;
            while (line != null) {
                sb.append("<span style='color: #666;'>").append(lineNumber).append(". </span>");
                if (line.endsWith("_1.fastq.gz")) {
        sb.append(line.replace("_1.fastq.gz", "<span style='color: blue'>_1.fastq.gz</span>"));
    } else if (line.endsWith("_2.fastq.gz")) {
        sb.append(line.replace("_2.fastq.gz", "<span style='color: red'>_2.fastq.gz</span>"));
    } else if (line.endsWith("_1.fastq")) {
        sb.append(line.replace("_1.fastq", "<span style='color: blue'>_1.fastq</span>"));
    }else if (line.endsWith("_2.fastq")) {
        sb.append(line.replace("_2.fastq", "<span style='color: red'>_2.fastq</span>"));
    } else {
        sb.append(line);
    }
                sb.append("<br>");
                line = br.readLine();
                lineNumber++;
            }
            sb.append("</html>");
            String file_list = sb.toString();

            // Use a JEditorPane to display the HTML content
            JEditorPane htmlPane = new JEditorPane("text/html", file_list);
            htmlPane.setEditable(false);
            // Wrap in scroll pane
            JScrollPane scrollPane = new JScrollPane(htmlPane);
            scrollPane.setPreferredSize(new Dimension(800, 500)); // Adjust size as needed
            check_files.add(scrollPane);

        } catch (FileNotFoundException ex) {
            Logger.getLogger(new_proj.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(new_proj.class.getName()).log(Level.SEVERE, null, ex);
        }

        // Add a panel for mode selection
        JPanel mode_panel = new JPanel();
        mode_panel.setLayout(new FlowLayout());

        JRadioButton quick_mode = new JRadioButton("Quick mode");
        JRadioButton advance_mode = new JRadioButton("Advance mode");

        ButtonGroup mode_group = new ButtonGroup();
        mode_group.add(quick_mode);
        mode_group.add(advance_mode);

        mode_panel.add(quick_mode);
        mode_panel.add(advance_mode);

        // Add the panels to the frame
        final JFrame frame = new JFrame("Files checking");
        frame.getContentPane().add(check_files, BorderLayout.CENTER);
        frame.getContentPane().add(mode_panel, BorderLayout.SOUTH);
        frame.pack();
        frame.setLocationRelativeTo(null);
        frame.setVisible(true);

        // Add a submit button
        JButton submit_button = new JButton("Submit");
        submit_button.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                if (quick_mode.isSelected()) {
                    int response = JOptionPane.showConfirmDialog(null,
                            "If you select quick mode, All of bioinformatics tools will run with default parameters.\nAre you sure?",
                            "Quick Mode Confirmation",
                            JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE);
                    if (response == JOptionPane.YES_OPTION) {
                        System.out.println("Quick mode selected");

                        int label = Runtime.getRuntime().availableProcessors();
                        String cores = String.valueOf(label / 2);
                        JTextField adjustField2 = new JTextField(cores);
                        JPanel myPanel = new JPanel();
                        myPanel.setLayout(new GridLayout(0, 1));
                        myPanel.add(new JLabel("Quick mode options"));
                        // Add radio buttons for Fastp and FastQC
                        myPanel.add(new JLabel("<html><h3>Quality Control Tool</h3></html>"));
                        JRadioButton fastpRadio = new JRadioButton("Fastp", true);   // default selected
                        JRadioButton fastqcRadio = new JRadioButton("FastQC");
                        ButtonGroup qcGroup = new ButtonGroup();
                        qcGroup.add(fastpRadio);
                        qcGroup.add(fastqcRadio);
                        myPanel.add(fastpRadio);
                        myPanel.add(fastqcRadio);
                        myPanel.add(new JLabel("<html><h3>Threads</h3></html>"));
                        myPanel.add(adjustField2);
                        System.out.println(new_workingDir);
                        JScrollPane scrPane = new JScrollPane(myPanel, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
                        scrPane.setPreferredSize(new Dimension(250, 250));
                        int result = JOptionPane.showConfirmDialog(null, scrPane,
                                "Please select MitoGEx option", JOptionPane.OK_CANCEL_OPTION);
                        if (result == JOptionPane.OK_OPTION) {
                            System.out.println("CPU Core");
                            System.out.println("\t--threads: " + adjustField2.getText());
                            System.out.println(path_Program);

                            String pathToRun = containsBam ? path_Program2 : path_Program;
                            String selectedQcTool = fastpRadio.isSelected() ? "fastp" : "fastqc";
                            String[] quick_command = {
                                pathToRun,
                                new_workingDir,
                                adjustField2.getText(), // CPU threads
                                jTextField2.getText(), // Project name
                                selectedQcTool, // Either "fastp" or "fastqc"
                                jTextField1.getText() // Input directory
                            };
                            Runtime r1 = Runtime.getRuntime();
                            try {
                                JOptionPane.showMessageDialog(null,
                                        "MitoGEx executing.... \n press ok button and wait until process success",
                                        "MitoGEx",
                                        JOptionPane.WARNING_MESSAGE);
                                // Determine the next log file name
                                File logDir = new File(new_workingDir + "/Logs/");
                                if (!logDir.exists()) {
                                    logDir.mkdir();
                                }
                                int logCounter = 1;
                                File logFile;
                                do {
                                    logFile = new File(logDir, "MitoGEx.log." + logCounter);
                                    logCounter++;
                                } while (logFile.exists());

                                ProcessBuilder builder = new ProcessBuilder(quick_command);
                                builder.redirectErrorStream(true);
                                Process p1 = builder.start();

                                // Set up reading the output
                                InputStream itsOutput = p1.getInputStream();
                                BufferedReader reader = new BufferedReader(new InputStreamReader(itsOutput));
                                BufferedReader stdError = new BufferedReader(new InputStreamReader(p1.getErrorStream()));

                                // Open the log file for writing
                                try (BufferedWriter logWriter = new BufferedWriter(new FileWriter(logFile))) {
                                    String line;
                                    while ((line = reader.readLine()) != null) {
                                        System.out.println(line);  // Print to terminal
                                        logWriter.write(line);  // Write to log file
                                        logWriter.newLine();
                                    }
                                    while ((line = stdError.readLine()) != null) {
                                        System.err.println(line);  // Print to terminal (error stream)
                                        logWriter.write(line);  // Write to log file
                                        logWriter.newLine();
                                    }
                                }

                                p1.waitFor();
                                if (p1.exitValue() == 0) {
                                    JOptionPane.showMessageDialog(null,
                                            "MitoGEx executed successfully.");
                                    // Close the JFrame and JPanel
                                    SwingUtilities.invokeLater(() -> {
                                        new_proj.this.dispose(); // Now you can close the JFrame
                                        check_files.setVisible(false); // Hide the JPanel
                                        frame.dispose();
                                    });

                                    if (comboBoxUpdater != null) {
                                        comboBoxUpdater.updateComboBox();
                                    }

                                } else {
                                    System.out.println("MitoGEx command failed");
                                }
                            } catch (IOException | InterruptedException ex) {
                                Logger.getLogger(new_proj.class.getName()).log(Level.SEVERE, (String) null, ex);
                            }
                        }
                    }
                } else if (advance_mode.isSelected()) {
                    System.out.println("Advance mode selected");

                    JFrame advancedFrame = new JFrame("Advanced Options");
                    advancedFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
                    advancedFrame.setLayout(new BorderLayout());

                    // Main Panel using GridLayout (2 columns)
                    JPanel advancedPanel = new JPanel(new GridLayout(0, 2, 20, 10));

                    // Left and Right Column Panels
                    JPanel leftPanel = new JPanel(new GridLayout(0, 1, 5, 5));
                    JPanel rightPanel = new JPanel(new GridLayout(0, 1, 5, 5));

                    // ** Define Dependencies (Each program requires input from another) **
                    Map<JCheckBox, JCheckBox> dependencies = new HashMap<>();

                    // Section 1: Quality Control
                    fastQCCheck = new JCheckBox("FastQC");
                    fastpCheck = new JCheckBox("Fastp");

//        fastQCCheck.setEnabled(containsGz);
//        fastpCheck.setEnabled(containsGz);
                    int label = Runtime.getRuntime().availableProcessors();
                    String cores = String.valueOf(label / 2);

                    fastpQualityField = new JTextField("Quality threshold (20-30)", 15);
                    fastpCore = new JTextField("Threads", 5);
                    fastQCCore = new JTextField("Threads", 5);
                    fastpUnqualified_base = new JTextField("Unqualified base limit", 15);
                    fastpReadLengthField = new JTextField("15",15);
                    applyPlaceholder(fastQCCore, "Threads");
                    applyPlaceholder(fastpCore, "Threads");
                    applyPlaceholder(fastpQualityField, "Quality threshold (20-30)");
                    applyPlaceholder(fastpUnqualified_base, "Unqualified base limit");
                    applyPlaceholder(fastpReadLengthField, "Read length (Default: 15");                    
                    fastpQualityField.setToolTipText("<html><b>-q, --qualified_quality_phred</b><br>The quality value that a base is qualified. Default 15 means phred quality >=Q15 is qualified. (int [=15])</html>");
                    fastpUnqualified_base.setToolTipText("<html><b>-u, --unqualified_percent_limit</b><br>How many percents of bases are allowed to be unqualified (0~100). Default 40 means 40% (int [=40])</html>");
                    fastpReadLengthField.setToolTipText("<html><b>-l, --length_required</b><br>reads shorter than length_required will be discarded, default is 15. (int [=15])</html>");
                    fastQCCore.setToolTipText("<html><b>-t</b><br>Number of threads. Default 4 )</html>");
                    fastpCore.setToolTipText("<html><b>-w</b><br>Number of threads. Default 4 )</html>");
                    fastpQualityField.setEnabled(false);
                    fastpCore.setEnabled(false);
                    fastpUnqualified_base.setEnabled(false);
                    fastQCCore.setEnabled(false);
                    fastpReadLengthField.setEnabled(false);
                    dependencies.put(fastpCheck, fastQCCheck); // Fastp requires FastQC

                    fastpCheck.addActionListener(evt -> {
                        boolean enabled = fastpCheck.isSelected();
                        fastpQualityField.setEnabled(enabled);
                        fastpCore.setEnabled(enabled);
                        fastpUnqualified_base.setEnabled(enabled);
                      fastpReadLengthField.setEnabled(enabled);
                        // Automatically select GATK checkboxes if BWA is selected
                        if (enabled) {
                            gatkCheck.setSelected(true);
                            mutect2Check.setSelected(true);
                            mitImpactCheck.setEnabled(enabled);
                            haploCheckCheck.setSelected(true);
                            haplogrepCheck.setEnabled(enabled);
                            gatkMemoryField.setEnabled(enabled);
//                            mutect2FilterField.setEnabled(enabled);
                            qualimapCheck.setSelected(true);
                            bwaCheck.setEnabled(enabled);
                            bwaCheck.setSelected(true);
                        } else {
                            // Optional: uncheck them if BWA is unselected
                            gatkCheck.setSelected(false);
                            mutect2Check.setSelected(false);
                            haploCheckCheck.setSelected(false);
                            mitImpactCheck.setSelected(false);
                            haplogrepCheck.setEnabled(false);
                            gatkMemoryField.setEnabled(enabled);
//                            mutect2FilterField.setEnabled(enabled);
                            qualimapCheck.setSelected(false);
                            bwaCheck.setSelected(false);
                        }

                        // Also update their enabled states
                        gatkCheck.setEnabled(enabled);
                        mutect2Check.setEnabled(enabled);
                        mitImpactCheck.setEnabled(enabled);
                        haploCheckCheck.setEnabled(false);
                        haplogrepCheck.setEnabled(enabled);
                        qualimapCheck.setEnabled(enabled);
                        qualimapThreads.setEnabled(enabled);
                        bwaCheck.setEnabled(enabled);
                        bwaThreadsField.setEnabled(enabled);
                         bwaMinimumScore.setEnabled(enabled);
                    });

                    fastQCCheck.addActionListener(evt -> {
                        boolean enabled = fastQCCheck.isSelected();
                        fastQCCore.setEnabled(enabled);
                        if (enabled) {
                            gatkCheck.setSelected(true);
                            mutect2Check.setSelected(true);
                            mitImpactCheck.setEnabled(enabled);
                            haploCheckCheck.setSelected(true);
                            haplogrepCheck.setEnabled(enabled);
                            gatkMemoryField.setEnabled(enabled);
//                            mutect2FilterField.setEnabled(enabled);
                            qualimapCheck.setSelected(true);
                            bwaCheck.setEnabled(enabled);
                            bwaCheck.setSelected(true);
                        } else {
                            // Optional: uncheck them if BWA is unselected
                            gatkCheck.setSelected(false);
                            mutect2Check.setSelected(false);
                            haploCheckCheck.setSelected(false);
                            mitImpactCheck.setSelected(false);
                            haplogrepCheck.setEnabled(false);
                            gatkMemoryField.setEnabled(enabled);
//                            mutect2FilterField.setEnabled(enabled);
                            qualimapCheck.setSelected(false);
                            bwaCheck.setSelected(false);
                        }

                        // Also update their enabled states
                        gatkCheck.setEnabled(enabled);
                        mutect2Check.setEnabled(enabled);
                        mitImpactCheck.setEnabled(enabled);
                        haploCheckCheck.setEnabled(false);
                        haplogrepCheck.setEnabled(enabled);
                        qualimapCheck.setEnabled(enabled);
                        qualimapThreads.setEnabled(enabled);
                        bwaCheck.setEnabled(enabled);
                        bwaThreadsField.setEnabled(enabled);
                         bwaMinimumScore.setEnabled(enabled);
                        fastpCheck.setEnabled(true);
                    });

                    JPanel qcPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
                    qcPanel.add(fastQCCheck);
                    qcPanel.add(fastQCCore);
                    qcPanel.add(fastpCheck);
                    qcPanel.add(fastpQualityField);
                    qcPanel.add(fastpCore);
                    qcPanel.add(fastpUnqualified_base);
                    qcPanel.add(fastpReadLengthField);
                    leftPanel.add(new JLabel("1. Quality Control"));
                    leftPanel.add(qcPanel);

                    // Section 2: Alignment
                    bwaCheck = new JCheckBox("BWA");
                    bwaThreadsField = new JTextField("Threads (default: 4)", 15);
                    bwaMinimumScore = new JTextField("Minimum score (Default: 30)",15);
                    applyPlaceholder(bwaThreadsField, "Threads (Default: 4)");
                    applyPlaceholder(bwaMinimumScore,"Minimum score");
                    bwaMinimumScore.setToolTipText("<html><b>-T</b><br>The minimum score to output an alignment (default 30).</html>");
                    bwaMinimumScore.setEnabled(false);
                    bwaThreadsField.setEnabled(false);
                    bwaCheck.setEnabled(false); // Initially disabled

                    dependencies.put(bwaCheck, fastpCheck); // BWA requires Fastp

                    bwaCheck.addActionListener(evt -> {
                        boolean enabled = bwaCheck.isSelected();
                        bwaThreadsField.setEnabled(enabled);
                         bwaMinimumScore.setEnabled(enabled);
                        // Automatically select GATK checkboxes if BWA is selected
                        if (enabled) {
                            gatkCheck.setSelected(true);
                            mutect2Check.setSelected(true);
                            mitImpactCheck.setEnabled(enabled);
                            haploCheckCheck.setSelected(true);
                            haplogrepCheck.setEnabled(enabled);
                            gatkMemoryField.setEnabled(enabled);
//                            mutect2FilterField.setEnabled(enabled);
                            qualimapCheck.setSelected(true);
                        } else {
                            // Optional: uncheck them if BWA is unselected
                            gatkCheck.setSelected(false);
                            mutect2Check.setSelected(false);
                            haploCheckCheck.setSelected(false);
                            mitImpactCheck.setSelected(false);
                            haplogrepCheck.setEnabled(false);
                            gatkMemoryField.setEnabled(enabled);
//                            mutect2FilterField.setEnabled(enabled);
                            qualimapCheck.setSelected(false);
                        }

                        // Also update their enabled states
                        gatkCheck.setEnabled(enabled);
                        mutect2Check.setEnabled(enabled);
                        mitImpactCheck.setEnabled(enabled);
                        haploCheckCheck.setEnabled(false);
                        haplogrepCheck.setEnabled(enabled);
                        qualimapCheck.setEnabled(enabled);
                        qualimapThreads.setEnabled(enabled);
                    });

                    JPanel alignPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
                    alignPanel.add(bwaCheck);
                    alignPanel.add(bwaThreadsField);
                    alignPanel.add(bwaMinimumScore);
                    leftPanel.add(new JLabel("2. Alignment"));
                    leftPanel.add(alignPanel);

                    // Section 3: Sort & Mark Duplicates
                    gatkCheck = new JCheckBox("GATK");
                    gatkMemoryField = new JTextField("Memory (default: 8GB)", 15);
                    applyPlaceholder(gatkMemoryField, "Memory (Default: 8GB)");
                    gatkMemoryField.setEnabled(false);
                    gatkCheck.setEnabled(false);

                    dependencies.put(gatkCheck, bwaCheck); // GATK requires BWA

                    gatkCheck.addActionListener(evt -> {
                        boolean enabled = gatkCheck.isSelected();
                        gatkMemoryField.setEnabled(enabled);
                        // Automatically select GATK checkboxes if BWA is selected
                        if (enabled) {

                            qualimapCheck.setEnabled(true);
                            qualimapThreads.setEnabled(true);
//                            mutect2FilterField.setEnabled(enabled);
                        } else {
                            // Optional: uncheck them if BWA is unselected
                            mitImpactCheck.setEnabled(enabled);
                            haplogrepCheck.setEnabled(enabled);
                            haploCheckCheck.setEnabled(false);
                            haploCheckCheck.setSelected(false);
                            mutect2Check.setSelected(false);
//                            mutect2FilterField.setEnabled(enabled);

                            qualimapCheck.setSelected(false);
                            qualimapThreads.setEnabled(false);

                        }

                        // Also update their enabled states
//                        mutect2FilterField.setEnabled(enabled);
                        qualimapCheck.setEnabled(enabled);
                    });

                    JPanel sortPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
                    sortPanel.add(gatkCheck);
                    sortPanel.add(gatkMemoryField);
                    leftPanel.add(new JLabel("3. Sort & Mark Duplicates"));
                    leftPanel.add(sortPanel);

                    // Section 4: Alignment Quality
                    qualimapCheck = new JCheckBox("Qualimap 2");
                    qualimapThreads = new JTextField("Threads", 15);
                    applyPlaceholder(qualimapThreads, "Threads");
                    qualimapThreads.setEnabled(false);
                    qualimapCheck.setEnabled(false);

                    dependencies.put(qualimapCheck, bwaCheck); // Qualimap requires BWA

                    qualimapCheck.addActionListener(evt -> qualimapThreads.setEnabled(qualimapCheck.isSelected()));

                    JPanel qualPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
                    qualPanel.add(qualimapCheck);
                    qualPanel.add(qualimapThreads);
                    leftPanel.add(new JLabel("4. Alignment Quality"));
                    leftPanel.add(qualPanel);

                    // Section 5: Variant Calling
                    mutect2Check = new JCheckBox("GATK (Mutect2)");
//                    mutect2FilterField = new JTextField("Min Variant Quality (default: 30)", 15);
//                    applyPlaceholder(mutect2FilterField, "Min Variant Quality (default: 30)");
//                    mutect2FilterField.setEnabled(false);
                    mutect2Check.setEnabled(false);

                    dependencies.put(mutect2Check, gatkCheck); // Mutect2 requires GATK

                    mutect2Check.addActionListener(evt -> {
                        boolean enabled = mutect2Check.isSelected();
//                        mutect2FilterField.setEnabled(enabled);

                        // Set Qualimap when Mutect2 is selected
                        qualimapCheck.setEnabled(enabled);
                        qualimapCheck.setSelected(enabled);
                        qualimapThreads.setEnabled(enabled);
                        // Automatically select GATK checkboxes if BWA is selected
                        if (enabled) {

                            mitImpactCheck.setEnabled(enabled);
                            haploCheckCheck.setSelected(true);
                            haplogrepCheck.setEnabled(enabled);
                        } else {
                            // Optional: uncheck them if BWA is unselected

                            qualimapCheck.setEnabled(true);
                            haploCheckCheck.setSelected(false);
                            mitImpactCheck.setSelected(false);

                            JOptionPane.showMessageDialog(null,
                                    "GATK (Mutect2) is not selected.\n\nThe following tools will be unavailable:\n"
                                    + "• MitImpact\n• Haplogrep 3\n• HaploCheck\n• FastTree",
                                    "Warning: Dependencies Disabled",
                                    JOptionPane.WARNING_MESSAGE);
                        }

                        // Also update their enabled states
                        mitImpactCheck.setEnabled(enabled);
                        haploCheckCheck.setEnabled(false);
                        haplogrepCheck.setEnabled(enabled);

                    });

                    JPanel variantPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
                    variantPanel.add(mutect2Check);
//                    variantPanel.add(mutect2FilterField);
                    leftPanel.add(new JLabel("5. Variant Calling"));
                    leftPanel.add(variantPanel);

                    // Section 6: Variant Annotation (Right Column)
                    mitImpactCheck = new JCheckBox("MitImpact");
                    mitImpactCheck.setEnabled(false);
                    dependencies.put(mitImpactCheck, mutect2Check); // MitImpact requires Mutect2

                    JPanel annotationPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
                    annotationPanel.add(mitImpactCheck);
                    rightPanel.add(new JLabel("6. Variant Annotation"));
                    rightPanel.add(annotationPanel);

                    // Section 7: Haplogroup Identification
                    haplogrepCheck = new JCheckBox("Haplogrep 3");
                    haplogrepCheck.setEnabled(false);
                    dependencies.put(haplogrepCheck, mutect2Check); // Haplogrep requires Mutect2

                    haplogrepCheck.addActionListener(evt -> {
                        boolean enabled = haplogrepCheck.isSelected();
//     haplogrepCheckField.setEnabled(enabled);
                        // Automatically select GATK checkboxes if BWA is selected
                        if (enabled) {

                            fastTreeCheck.setEnabled(true);

                        } else {
                            // Optional: uncheck them if BWA is unselected

                            fastTreeCheck.setSelected(false);
                        }

                        // Also update their enabled states
                        fastTreeCheck.setEnabled(enabled);

                    });
                    JPanel haploPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
                    haploPanel.add(haplogrepCheck);
                    rightPanel.add(new JLabel("7. Haplogroup Identification"));
                    rightPanel.add(haploPanel);

                    // Section 8: Phylogenetic Tree
                    fastTreeCheck = new JCheckBox("FastTree");
                    fastTreeCheck.setEnabled(false);
                    dependencies.put(fastTreeCheck, haplogrepCheck); // FastTree requires BWA

                    JPanel treePanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
                    treePanel.add(fastTreeCheck);
                    rightPanel.add(new JLabel("8. Phylogenetic Tree"));
                    rightPanel.add(treePanel);

                    // Section 9: Contamination Check
                    haploCheckCheck = new JCheckBox("HaploCheck");
                    haploCheckCheck.setEnabled(false);
                    dependencies.put(haploCheckCheck, mutect2Check); // HaploCheck requires Mutect2

                    JPanel contaminationPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
                    contaminationPanel.add(haploCheckCheck);
                    rightPanel.add(new JLabel("9. Contamination Check"));
                    rightPanel.add(contaminationPanel);

                    // Add both panels to the main panel
                    advancedPanel.add(leftPanel);
                    advancedPanel.add(rightPanel);

                    // **Fix the Apply Button Position**
                    JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
                    JButton applyAdvancedButton = new JButton("Apply Advanced Options");
                    applyAdvancedButton.addActionListener(new ActionListener() {
                        @Override
                        public void actionPerformed(ActionEvent evt) {

                            try {
                                // Execute the selected tools with user input
                                executeTool();
                            } catch (IOException ex) {
                                Logger.getLogger(new_proj.class.getName()).log(Level.SEVERE, null, ex);
                            }

                        }
                    });
                    buttonPanel.add(applyAdvancedButton);

                    // **Enable dependencies dynamically**
                    for (Map.Entry<JCheckBox, JCheckBox> entry : dependencies.entrySet()) {
                        JCheckBox dependent = entry.getKey();
                        JCheckBox required = entry.getValue();

                        required.addActionListener(evt -> dependent.setEnabled(required.isSelected()));
                    }

                    if (containsGz == true) {
                        System.out.println("All tools can select.");

                    } else if (containsBam == true) {
                        fastQCCheck.setSelected(false);
                        fastQCCheck.setEnabled(false);

                        fastpCheck.setSelected(false);
                        fastpCheck.setEnabled(false);

                        gatkCheck.setEnabled(true);
                        gatkCheck.setSelected(true);
                        gatkMemoryField.setEnabled(true);
                        qualimapCheck.setEnabled(true);
                        qualimapCheck.setSelected(true);
                        qualimapThreads.setEnabled(true);
                        mutect2Check.setEnabled(true);
                        mutect2Check.setSelected(true);
//                        mutect2FilterField.setEnabled(true);
                        mitImpactCheck.setEnabled(true);
                        haplogrepCheck.setEnabled(true);
//    haploCheckCheck.setEnabled(true);
                        haploCheckCheck.setSelected(true);
                    }

                    // Display Panel in a New Window
                    advancedFrame.add(new JScrollPane(advancedPanel), BorderLayout.CENTER);
                    advancedFrame.add(buttonPanel, BorderLayout.SOUTH);
                    advancedFrame.pack();
                    advancedFrame.setLocationRelativeTo(null);
                    advancedFrame.setVisible(true);

                    // Handle Apply Button Click
                    applyAdvancedButton.addActionListener(evt
                            -> JOptionPane.showMessageDialog(advancedFrame, "Advanced options applied."));

                }
            }

        });

        mode_panel.add(submit_button);
    }//GEN-LAST:event_jButton2ActionPerformed

    private void applyPlaceholder(JTextField field, String placeholder) {
        field.setText(placeholder);
//    field.setPreferredSize(new Dimension(250, field.getPreferredSize().height)); // Set the size

        field.addFocusListener(new java.awt.event.FocusAdapter() {
            @Override
            public void focusGained(java.awt.event.FocusEvent evt) {
                if (field.getText().equals(placeholder)) {
                    field.setText("");
                }
            }

            @Override
            public void focusLost(java.awt.event.FocusEvent evt) {
                if (field.getText().isEmpty()) {
                    field.setText(placeholder);
                }
            }
        });
    }

    private void executeTool() throws IOException {
         // Retrieve the user inputs from text fields and check for null values
        String fastpThreshold = (fastpQualityField.getText().trim().isEmpty())
                ? fastpQualityField.getText().trim() : "15";
        String fastpCoreValue = (fastpCore.getText().trim().isEmpty())
                ? fastpCore.getText().trim() : "4";
        String fastpUnqualifiedValue = (fastpUnqualified_base.getText().trim().isEmpty())
                ? fastpUnqualified_base.getText().trim() : "40";
        String fastpReadLengthValue = (fastpReadLengthField.getText().trim().isEmpty())
                ? fastpReadLengthField.getText().trim() : "15";
        String bwaThreadsValue = (bwaThreadsField.getText().trim().isEmpty())
                ? bwaThreadsField.getText().trim() : "4";  // Get threads for BWA
        String bwaMinimumScoreValue = (bwaMinimumScore.getText().trim().isEmpty())
                ? bwaMinimumScore.getText().trim() : "30";

        
       
        String workingDir = System.getProperty("user.dir");
        String new_workingDir = workingDir.replaceAll("target", "");
        String path_Program = new_workingDir + "/Software/file_log/all_file_log.txt";
        String path_output = new_workingDir + "/Results/Fastp/";
        String logDirPath = new_workingDir + "/Logs/";
        File logDir = new File(logDirPath);
        if (!logDir.exists()) {
            logDir.mkdirs();
        }

// Find next available log file name
        int logCounter = 1;
        File logFile;
        do {
            logFile = new File(logDir, "MitoGEx_advanced.log." + logCounter);
            logCounter++;
        } while (logFile.exists());

// Prepare the log writer
        BufferedWriter logWriter = new BufferedWriter(new FileWriter(logFile));
        if (fastQCCheck != null && fastQCCheck.isSelected()) {
            System.out.println("FastQC is selected.");

            String fastqcScript = new_workingDir + "/Software/scripts/./qualityControl_FastQC_rCRS.sh";
            String cores = fastQCCore.getText().trim();
            if (cores.isEmpty() || cores.contains("Default")) {
                cores = "4";
            }

            String fastqcCommand = String.format("%s %s %s", fastqcScript, new_workingDir, cores);
            logWriter.write("Running FastQC command: " + fastqcCommand);
            logWriter.newLine();

            boolean success = runCommand(fastqcCommand, new_workingDir, logWriter);
            if (success) {
                SwingUtilities.invokeLater(() -> fastQCCheck.setEnabled(false));
            }
        }

        // Construct the command for Fastp
        if (fastpCheck != null && fastpCheck.isSelected()) {

            System.out.println("Fastp is selected.");

            List<String> r1Paths = new ArrayList<>();

            try (BufferedReader reader = new BufferedReader(new FileReader(path_Program))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    if (line.contains("_1.fastq.gz")) {
                        r1Paths.add(line.trim());
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            boolean allSuccess = true;

            for (String r1Path : r1Paths) {
                String r2Path = r1Path.replace("_1.fastq.gz", "_2.fastq.gz");

                File r2File = new File(r2Path);
                if (!r2File.exists()) {
                    System.out.println("Missing pair for: " + r1Path);
                    continue;
                }

                // Extract sample name from file path
                String fileName = new File(r1Path).getName(); // e.g., TMRC65015_1.fastq.gz
                String sampleName = fileName.replace("_1.fastq.gz", "");

                // Create per-sample output directory
                File sampleFolder = new File(path_output, sampleName);
                if (!sampleFolder.exists()) {
                    sampleFolder.mkdirs();
                }

                // Output file paths
                String outputR1 = new File(sampleFolder, sampleName + "_1.fastq.gz").getAbsolutePath();
                String outputR2 = new File(sampleFolder, sampleName + "_2.fastq.gz").getAbsolutePath();

                // Print for debugging
                System.out.println("Sample: " + sampleName);
                System.out.println("R1: " + r1Path);
                System.out.println("R2: " + r2Path);
                System.out.println("OutputR1: " + outputR1);
                System.out.println("OutputR2: " + outputR2);

                // Build and run fastp command
                String fastpCommand = String.format(
                        "fastp -q %s -u %s -w %s -l %s -i %s -I %s -o %s -O %s --verbose --html %s.html --json %s.json",
                        fastpThreshold, fastpUnqualifiedValue, fastpCoreValue, fastpReadLengthValue,
                        r1Path, r2Path, outputR1, outputR2, sampleName, sampleName
                );

                System.out.println("Running command: " + fastpCommand);
                logWriter.write("Running command: " + fastpCommand);
                logWriter.newLine();
                String sampleDir = sampleFolder.getAbsolutePath();
                boolean success = runCommand(fastpCommand, sampleDir, logWriter);
                if (!success) {
                    allSuccess = false;
                }

            }
            if (allSuccess) {
                SwingUtilities.invokeLater(() -> fastpCheck.setEnabled(false));
            }
        }

        // Construct the command for BWA
        if (bwaCheck != null && bwaCheck.isSelected()) {
            System.out.println("BWA is selected");

            String bwaScript = new_workingDir + "/Software/scripts/align_rCRS.sh";

            String userInputDir = jTextField1.getText(); // From Browse

            String bwaCommand = String.format("%s %s %s %s %s", bwaScript, new_workingDir, bwaThreadsValue, userInputDir, bwaMinimumScoreValue);

            logWriter.write("Running BWA command: " + bwaCommand);
            logWriter.newLine();

            boolean bwaSuccess = runCommand(bwaCommand, new_workingDir, logWriter);
            if (bwaSuccess) {
                SwingUtilities.invokeLater(() -> bwaCheck.setEnabled(false));
            }
        }

        if (gatkCheck != null && gatkCheck.isSelected()) {
            System.out.println("Sort & Add Read Groups (Picard) is selected");

            String sortScript = new_workingDir + "/Software/scripts/sort_rCRS.sh";

           String rawMem = gatkMemoryField.getText().trim();
// ถ้าว่าง -> ใช้ "8", ถ้าไม่ว่าง -> ใช้ค่าที่พิมพ์
String gatkMemoryFieldValue = (rawMem.isEmpty()) ? "8" : rawMem;

// จัด Format ให้เป็น -Xmx...g
if (!gatkMemoryFieldValue.startsWith("-Xmx")) {
    gatkMemoryFieldValue = "-Xmx" + gatkMemoryFieldValue + "g";
}

            if (!gatkMemoryFieldValue.startsWith("-Xmx")) {
                gatkMemoryFieldValue = "-Xmx" + gatkMemoryFieldValue + "g";
            }

            String projectTitle = jTextField2.getText().trim();
            if (projectTitle.isEmpty()) {
                projectTitle = "MitoGEx";
            }
            String bamInputPath = containsBam ? jTextField1.getText().trim() : new_workingDir + "/Results/BAM_rCRS";

            String sortCommand = String.format("%s %s %s \"%s\" \"%s\" \"%s\"",
                    sortScript, new_workingDir, bwaThreadsValue, gatkMemoryFieldValue, projectTitle, bamInputPath);

            logWriter.write("Running Sort & Add Groups command: " + sortCommand);
            logWriter.newLine();

    boolean sortSuccess = runCommand(sortCommand, new_workingDir, logWriter);
    if (sortSuccess) {
        SwingUtilities.invokeLater(() -> gatkCheck.setEnabled(false));
    }
        }

        if (qualimapCheck != null && qualimapCheck.isSelected()) {
            System.out.println("Qualimap is selected");

            String qualimapScript = new_workingDir + "/Software/scripts/alignQuality_rCRS.sh";

            //Did not fix
            String qualimapThreadsValue = (qualimapThreads.getText().trim().isEmpty())
                    ? qualimapThreads.getText().trim() : "8";

            boolean isMutect2Selected = mutect2Check != null && mutect2Check.isSelected();
            String bamDir = isMutect2Selected
                    ? "Main_analysis_pipeline_output/Align"
                    : "Sort_rCRS";

            String qualimapCommand = String.format("%s %s %s %s", qualimapScript, new_workingDir, qualimapThreadsValue, bamDir);

            logWriter.write("Running Qualimap command: " + qualimapCommand);
            logWriter.newLine();

            boolean qualimapSuccess = runCommand(qualimapCommand, new_workingDir, logWriter);
            if (qualimapSuccess) {
                SwingUtilities.invokeLater(() -> {
                    qualimapCheck.setEnabled(false);

                    if (!isMutect2Selected) {
                        // Disable downstream tools
                        mutect2Check.setEnabled(false);
                        mutect2Check.setSelected(false);

                        mitImpactCheck.setEnabled(false);
                        mitImpactCheck.setSelected(false);

                        haplogrepCheck.setEnabled(false);
                        haplogrepCheck.setSelected(false);

                        haploCheckCheck.setEnabled(false);
                        haploCheckCheck.setSelected(false);

                        fastTreeCheck.setEnabled(false);
                        fastTreeCheck.setSelected(false);

                        // 🔔 Show message to the user
                        JOptionPane.showMessageDialog(this,
                                "You did not select GATK (Mutect2), so the following tools are disabled:\n\n"
                                + "• MitImpact\n• Haplogrep 3\n• HaploCheck\n• FastTree",
                                "Tool Dependency Warning",
                                JOptionPane.WARNING_MESSAGE);
                    }
                });
            }
        }

        if (mutect2Check != null && mutect2Check.isSelected()) {
            System.out.println("Variant Calling mutect2 is selected");

            String mutect2Script = new_workingDir + "/Software/scripts/mitPipeline_rCRS.sh";

//            String mutect2FilterFieldValue = (mutect2FilterField.getText().trim().isEmpty())
//                    ? mutect2FilterField.getText().trim() : "30";

            String mutect2Command = String.format("%s %s %s ",
                    mutect2Script, new_workingDir, bwaThreadsValue);

            logWriter.write("Running Sort & Add Groups command: " + mutect2Command);
            logWriter.newLine();

    boolean mutect2Success = runCommand(mutect2Command, new_workingDir, logWriter);
    if (mutect2Success) {
        SwingUtilities.invokeLater(() -> mutect2Check.setEnabled(false));
    }
        }

        if (mitImpactCheck != null && mitImpactCheck.isSelected()) {
            System.out.println("Variant Annotation mitImpact is selected");

            String mitImpactScript = new_workingDir + "/Software/scripts/annotate_rCRS.sh";

//    String mitImpactFilterFieldValue = (mitImpactFilterField.getText().trim().isEmpty()) 
//                                       ? mitImpactFilterField.getText().trim() : "30";
            String mitImpactCommand = String.format("%s %s %s",
                    mitImpactScript, new_workingDir, bwaThreadsValue);

            logWriter.write("Running mitImpact command: " + mitImpactCommand);
            logWriter.newLine();

             boolean mitImpactSuccess = runCommand(mitImpactCommand, new_workingDir, logWriter);
             if (mitImpactSuccess) {
                 SwingUtilities.invokeLater(() -> mitImpactCheck.setEnabled(false));
             }
        }

        if (haplogrepCheck != null && haplogrepCheck.isSelected()) {
            System.out.println("Haplogroup Identification haplogrep is selected");

            String haplogrepScript = new_workingDir + "/Software/scripts/haplogroupClassifier_rCRS.sh";

//    String haplogrepFilterFieldValue = (haplogrepFilterField.getText().trim().isEmpty()) 
//                                       ? haplogrepFilterField.getText().trim() : "30";
            String haplogrepCommand = String.format("%s %s %s",
                    haplogrepScript, new_workingDir, bwaThreadsValue);

            logWriter.write("Running haplogrep command: " + haplogrepCommand);
            logWriter.newLine();

             boolean haplogrepSuccess = runCommand(haplogrepCommand, new_workingDir, logWriter);
             if (haplogrepSuccess) {
                 SwingUtilities.invokeLater(() -> haplogrepCheck.setEnabled(false));
             }
        }

        if (fastTreeCheck != null && fastTreeCheck.isSelected()) {
            System.out.println("Phylogenetic Tree fastTree is selected");

            String fastTreeScript = new_workingDir + "/Software/scripts/phylogenetic_rCRS.sh";

//    String fastTreeFilterFieldValue = (fastTreeFilterField.getText().trim().isEmpty()) 
//                                       ? fastTreeFilterField.getText().trim() : "30";
            String fastTreeCommand = String.format("%s %s %s",
                    fastTreeScript, new_workingDir, bwaThreadsValue);

            logWriter.write("Running fastTree command: " + fastTreeCommand);
            logWriter.newLine();

             boolean fastTreeSuccess = runCommand(fastTreeCommand, new_workingDir, logWriter);
             if (fastTreeSuccess) {
                 SwingUtilities.invokeLater(() -> fastTreeCheck.setEnabled(false));
             }
        }

        try {
            logWriter.close();
            JOptionPane.showMessageDialog(this, "Advanced mode complete. Log saved to: " + logFile.getAbsolutePath());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private boolean runCommand(String command, String workingDirPath, BufferedWriter logWriter) {
        boolean success = false;
        try {
            ProcessBuilder processBuilder = new ProcessBuilder("/bin/bash", "-c", command);
            if (workingDirPath != null && !workingDirPath.trim().isEmpty()) {
                processBuilder.directory(new File(workingDirPath));
            }
            processBuilder.redirectErrorStream(true);
            Process process = processBuilder.start();

            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
                logWriter.write(line);
                logWriter.newLine();
            }

            process.waitFor();
            success = (process.exitValue() == 0);
            if (!success) {
                logWriter.write("Command failed: " + command);
                logWriter.newLine();
            }
        } catch (IOException | InterruptedException e) {
            try {
                logWriter.write("Exception occurred: " + e.getMessage());
                logWriter.newLine();
            } catch (IOException ioEx) {
                ioEx.printStackTrace();
            }
            e.printStackTrace();
        }
        return success;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(new_proj.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(new_proj.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(new_proj.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(new_proj.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new new_proj(null).setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JCheckBox jCheckBox1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JTextField jTextField2;
    // End of variables declaration//GEN-END:variables
}
